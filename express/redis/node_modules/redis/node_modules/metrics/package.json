{
  "name": "metrics",
  "description": "A node.js port of Coda Hale's metrics library.  In use at Yammer.",
  "version": "0.1.6",
  "repository": {
    "type": "git",
    "url": "git://github.com/mikejihbe/metrics.git"
  },
  "author": {
    "name": "Mike Ihbe",
    "email": "mikejihbe@gmail.com",
    "url": "mikeihbe.com"
  },
  "directories": {
    "lib": "."
  },
  "engines": {
    "node": ">=0.4.x"
  },
  "dependencies": {},
  "devDependencies": {},
  "readme": "Metrics\n=======\n\n* A node.js port of codahale's metrics library: https://github.com/codahale/metrics\n\nHow to Use\n----------\n\n**Import Metrics**\n\n```javascript\nmetrics = require('./../deps/metrics')\n```\n\n**Start a metrics Server**\n\n```javascript\nmetricsServer = new metrics.Server(config.metricsPort || 9091);\n```\n\n**Create some metrics**\n\n```javascript\n  // Counters count things. They implement inc, dec, clear\nvar counterForThingA = new metrics.Counter\n  // Histograms collect a sample's distribution. They're highly configurable,\n  // so check out the actual implementation if the defaults don't fit your needs\n  // (but they probably will).  This is useful for tracking how long things take\n  // for instance.  Exponential decay histograms favor more recent data, which\n  // is typically what you want\n  , histForThingB = new metrics.createExponentialDecayHistogram()\n  , histForThingC = new metrics.createUniformHistogram()\n  // A meter tracks how often things happen. It exposes a 1 minute rate, a 5 minute rate, and a 15 minute rate\n  // using exponentially weighted moving averages (the same strategy that unix load average takes)\n  , meterForThingD = new metrics.Meter\n  // A Timer is a combination of a meter and a histogram.  Everything you could possibly want!\n  , timerForThingE = new metrics.Timer;\n```\n\n**Add the metrics to the server**\n\n```javascript\nmetricsServer.addMetric('com.co.thingA', counterForThingA);\nmetricsServer.addMetric('com.co.thingB', counterForThingB);\nmetricsServer.addMetric('com.co.thingC', counterForThingC);\nmetricsServer.addMetric('com.co.thingD', counterForThingD);\n```\n\n\nAdvanced Usage\n--------------\nTypical production deployments have multiple node processes per server.  Rather than each process exposing metrics on different ports, it makes more sense to expose the metrics from the \"master\" process.  Writing a thin wrapper around this api to perform the process communication is trivial, with a message passing setup, the client processes could look something like this:\n\n```javascript\nvar Metric = exports = module.exports = function Metrics(messagePasser, eventType) {\n  this.messagePasser = messagePasser;\n  this.eventType = eventType;\n}\n\nMetric.prototype.newMetric = function(type, eventType) {\n  this.messagePasser.sendMessage({\n    method: 'createMetric'\n    , type: type\n    , eventType: eventType\n  });\n}\nMetric.prototype.forwardMessage = function(method, args) {\n  this.messagePasser.sendMessage({\n    method: 'updateMetric'\n    , metricMethod: method\n    , metricArgs: args\n    , eventType: this.eventType\n  }); \n}\n\nMetric.prototype.update = function(val) { return this.forwardMessage('update', [val]); }\nMetric.prototype.mark = function(n) { return this.forwardMessage('mark', [n]); }\nMetric.prototype.inc = function(n) { return this.forwardMessage('inc', [n]); }\nMetric.prototype.dec = function(n) { return this.forwardMessage('dec', [n]); }\nMetric.prototype.clear = function() { return this.forwardMessage('clear'); }\n```\n\nAnd the server side that receives the createMetric and updateMetric rpcs could look something like this:\n\n```javascript\n{\n  createMetric: function(msg) {\n      if (metricsServer) {\n        msg.type = msg.type[0].toUpperCase() + msg.type.substring(1)\n        metricsServer.addMetric(msg.eventType, new metrics[msg.type]);\n      }\n   }\n  updateMetric: function(msg) {\n    if (metricsServer) {\n    var namespaces = msg.eventType.split('.')\n      , event = namespaces.pop()\n      , namespace = namespaces.join('.');\n    var metric = metricsServer.trackedMetrics[namespace][event];\n    metric[msg.metricMethod].apply(metric, msg.metricArgs);\n  }\n}\n```\n\nFor multiple server deployments, you have more options, but the best approach will be highly application dependent. Best of luck, and always be tracking!\n\nHow to Collect\n--------------\n\nHit the server on your configured port and you'll get a json representation of your metrics.  You should collect these periodically to generate timeseries to monitor the health of your application.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/mikejihbe/metrics/issues"
  },
  "_id": "metrics@0.1.6",
  "dist": {
    "shasum": "5f16334d803c30f6a873d3f5b27bbf7e0b966f57"
  },
  "_from": "metrics@>=0.1.5",
  "_resolved": "https://registry.npmjs.org/metrics/-/metrics-0.1.6.tgz"
}
